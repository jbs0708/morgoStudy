# [Gold IV] 특정한 최단 경로 - 1504 

[문제 링크](https://www.acmicpc.net/problem/1504) 

### 성능 요약

메모리: 75732 KB, 시간: 872 ms

### 분류

데이크스트라, 그래프 이론, 최단 경로

### 제출 일자

2024년 7월 18일 09:09:32

### 문제 설명

<p>방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.</p>

<p>세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v<sub>1</sub>과 v<sub>2</sub>가 주어진다. (v<sub>1</sub> ≠ v<sub>2</sub>, v<sub>1</sub> ≠ N, v<sub>2</sub> ≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.</p>

### 접근법
1. 정점 두개를 v1, v2로 두고 시작점과 끝점은 S, E로 둔 상태에서 가능한 경우의 수를 생각해볼 때, S -> v1 -> v2 -> E 와 S -> v2 -> v1 -> E 두 가지 방법이 있다.
2. 각 경로의 최단거리를 구하여 합을 구한 뒤에 더 짧은 거리를 가지는 방법이 최단거리일 것이다.
3. 다익스트라(우선순위 큐, BFS) 알고리즘을 활용하여 어떤 지점에서 다른 지점으로 가는 최단거리를 구하는 함수를 정의
4. 가능한 경우의 수를 따라 연산

### CODE
'''java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    static List<List<int[]>> graph = new ArrayList<>();
    static int N;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        int E = Integer.parseInt(st.nextToken());

        for (int i = 0; i <= N; i++) {
            graph.add(new ArrayList<>());
        }

        for (int i = 0; i < E; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int d = Integer.parseInt(st.nextToken());
            graph.get(s).add(new int[] {e, d});
            graph.get(e).add(new int[] {s, d});
        }

        st = new StringTokenizer(br.readLine());
        int v1 = Integer.parseInt(st.nextToken());
        int v2 = Integer.parseInt(st.nextToken());

        if (E == 0) {
            System.out.println(-1);
        } else if (N == E) {
            System.out.println(0);
        } else {
            int path1 = dijkstra(1, v1) + dijkstra(v1, v2) + dijkstra(v2, N);
            int path2 = dijkstra(1, v2) + dijkstra(v2, v1) + dijkstra(v1, N);

            int ans = Math.min(path1, path2);
            if (ans < 0) {
                ans = -1;
            }

            System.out.println(ans);
        }
    }


    public static int dijkstra(int start, int end) {
        if (start == end) {
            return 0;
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparing(a -> a[1]));
        int[] dis = new int[N+1];
        Arrays.fill(dis, Integer.MAX_VALUE);

        pq.add(new int[] {start, 0});
        dis[start] = 0;

        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int curNode = cur[0];
            int curWeight = cur[1];

            if (dis[curNode] < curWeight) {
                continue;
            }

            for (int[] neighbor : graph.get(curNode)) {
                int nextNode = neighbor[0];
                int weight = dis[curNode] + neighbor[1];

                if (weight < dis[nextNode]) {
                    dis[nextNode] = weight;
                    pq.add(new int[] {nextNode, weight});
                }
            }
        }

        return dis[end];
    }
}


'''

